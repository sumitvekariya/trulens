{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":12579689260735611596,"abi":{"parameters":[{"name":"image_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"device_id","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"latitude","type":{"kind":"integer","sign":"signed","width":64},"visibility":"private"},{"name":"longitude","type":{"kind":"integer","sign":"signed","width":64},"visibility":"private"},{"name":"gps_enabled","type":{"kind":"boolean"},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"attestation_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7V3bjhzHsfwXPvOh7hf9yoFhUBJtECBIQaIOYAj6d/dKnJ41qzoLzKntjc6sF2PX7NiJSNVkZmdVR//x5uf3P/7+739++PSvz7+9+eH//njz8fNP7758+Pxp++2PN7bmv/7P33559+np99++vPv1y5sfrC/l7Zv3n37efky2/Pn2zb8+fHz/5ofk/nzbuTjsF/ts7xfb3sUx7n84P7/0H283MgWJTMUh44xBImNPJlP912ud8Q0Zh0TGI5EJSGTi2WTcjYy1DZmERCYjkSlIZE7OwM7nG5lQviVjDRIZi0TGIZHxZ5NJNzIxNWQCEpmIRCYhkTk5A7uyJ73aFEpbkMhUIDLOIJE5OwMX+/Vab5pC6RwSGY9EJiCROTkDe3crlN43hdIlJDIZiUxBIlPPJnMrlD40hdIbJDIWiYxDInNyBvb5Vih9aQqlD0hkIhKZhETm7Ayc90JZm0LpCxKZCkQmGCQyJ2fgYG+FMrimUAaHRMYjkQlIZOLZZG6FMvimUIaERCYjkSlIZE7OwCHdCmXITaGMBomMRSLjkMhMyMDR1tvFMTiaDLlhGgMSmYhEJiGRySeToTZMY0EiU4HIJINExp5NhtgwTQ6JjEciE5DInJyByQ3TlJDIZCQyBYlMPZsMsWGaDRIZi0TGIZE5OQOTG6Y5IJGJSGQSEpmzMzC1YZoLEpkKRKYYJDInZ2Byw7Q4JDIeiUxAIhPPJkNsmJaERCYjkSlIZE7OwOSGaTVIZCwSGYdE5uwMTG2Y1oBEJiKRSUhkTs7A5IZpLUhkKg4ZbwwSGXs2meMNU28cEhmPRCYgkTk5A1Mbpt4kJDIZiUxBIjMhA+d4K342/+8ntBenfCOeSpP0ZjwTN4+MRSLjkMh4JDIBiUxEIpOQyGQkMuVcMtncrs0mN2QqEBlnkMhYJDIOiYxHIhOQyEQkMgmJTEYig5SBHVIG9kgZ2CNlYI+Ugf3ZPXC99TO5HRb5gEQmIpE5OwPvZIrL9KXU0WHv80V5l4vyrtfkHcxFeduL8na4vIlj5T74i/IOF+UdL8obuF6SvIHrJckbuF6SvIHrJcU7AtdL4hEPH4HrJckbuV5SvJHrJcUbt15Sj6P4iFsvad649ZLmjVsvad649ZLmjVsvSd4Jt15Sjyr5hFsvad649ZLmjVsvad7A9ZJ4rMon4HpJ8gaulyRv4HpJ8gaulyRv4HpJ8c7A9ZJ45M5n4HpJ8gaulyRv4HpJ8satl9TjgT7j1kuaN269pHnj1kuaN269pHnj1kuSd8Gtl9Sjo77g1kuaN269pHnj1kuaN3C9JB5z9QW4XpK8geslyRu4XpK8geslyRu4XlK8K3C9JB6B9hW4XpK8geslyRu4XpK8cesl+bh2xa2XNG/ceknzxq2XNG/ceknzxq2XFO9gcOsl9Sh/MLj1kuaNWy9p3rj1kuYNXC8J24FggOslyRu4XpK8geslyRu4XpK8geslxXuGA0cx5nZxcQ88ph9mOHDMI+OQyHgkMgGJTEQik5DIZCQyBYlMPZcM9WBxcAaJjEUi45DIeCQyAYlMRCKTkMhkJDIFiQxSBvZIGdgjZWCPlIE9Ugb2J2dgyvQi+IhEJiGROTsDz7EdCL5clHe9Ju9gLsrbXpS3uyhvj8ubeAw+zLDVeBXe8aK800V5A9dLkjdwvSR5A9dLincErpckb+B6Sdg8hAhcL0neyPWS4o1cLyneuPWSsh0IEbde0rxx6yXNG7de0rxx6yXJO+HWS5o3br2kbB5Cwq2XNG/ceknzxq2XNG/geknYDoQEXC9J3sD1kuQNXC9J3sD1kuKdgeslyRu4XhI2DyED10uSN3C9JHkD10uSN269pGwHQsatlzRv3HpJ88atlzRv3HpJ8i649ZLmjVsvKZuHUHDrJc0bt17SvHHrJc0buF4StgOhANdLkjdwvSR5A9dLkjdwvaR4V+B6SfIGrpeEzUOowPWS5A1cL0newPWS5I1bL0nbgYpbL2neuPWS5o1bL2neuPWS4h0Nbr2keePWS8rmIRrceknzxq2XNG/ceknzBq6XhO1ANMD1kuQNXC9J3sD1kuQNXC8p3ha4XpK8H6+XzuTbAxTOlCZjTbDVGH2Cf/FPCC/+CfHFPyG9+CfkF/+E8uKfUF/6EybYP4w+4cW/0+7Fv9Puxb/T7sW/0+7Fv9Puxb/T7sW/0+7Fv9Puxb/T/sW/0xNcApyL+4MybmQ3lvZrU372d3Ovb9manxuJGOPzi/9i7i7L3F+Webgs83hZ5umyzPNlmZfLMq9XZT7BOeG1mF+2hobL1tBw2Ro6wUHhtZhftoaGy9bQcNkaGi5bQwNwDc057bNc7+mLayw3mduP6VuZEbjgzpQJXJ1nygQu5d8nM9VdZvWNTOC6P1NmECIzmNvFNbg0Sssm7cb12w5pbqIC3IC8YlSAm5uZCQ64E5opE7htmpngxPRYpMwkpceamrGSlJZsblTEdHBkgktiOjhaZtCR4KS0ZAOZUnosF245qLpsGpk6eqwkpseiZeqYY2Udc6wsZo5FZtqsY46VpXRBU1vgCW42EqMipseiE5yOOVYW02PRCU7HHCtL6bGmZqyyxl69qOjYiSw65lhFx07kBMOkS8iU0mPRA56io8cqOuZYRcccq+iYY1Uxcywy01Ydc6wqpQua2gLXNfbqRSXoSHA65lhVTI9FJzgdc6wqpceam7HW2KuNSjIqdiKTUTHHSkbFTmQyKuZYyQQNA55kVPRYyaiYYyWjYo6VjIo5VjIqzrwnq2KOlew6xN5pge0ae/WiouLMe5phZ3gFmSrOvCerYo6VrJQea27GWmOvXlRU7EQmp2OO5VTsRCanY47lpPRY9IBnhr3sFb6bOuZYTsccy+mYYzkVZ96T0zHH8usQe6cFRjaMfsWoqDjznpCdq2fKDDoSnI45FrKB9itmrDX26kVFx04kskv4RJnIluITExyy//hMmVJ6LHrAg+xsPvO7GXTI1DHHQjZYnylTxZn3hGzdPlPmOsTeaYHF2MLPjYqOM+9yXORpmTrOvItxkR/IXLbwvYy1xl69qOjYiZTjIk/L1LETKcZFfiBTSo9FD3h0+LwnHT7vSY7POy1TxxxLjM/7INPqmGOJ8Xmf2gKLsYWfGhUdLvJJjos8LVPHmXcxLvIDmWFlrE7GWmOvXlR07ETKcZGnZerYiRTjIk/LFGMLTw94dPi8Jx0+70mOzzstM+iQqePMuxyfd1rmOsTeaYHF2MLPjYqOM+9yXORpmTrOvItxkR/IXLbwnYwlxhZ+blR07ETKcZGnZerYiRTjIj+QKaXHIgc8WYfPe9bh857l+LzTMlXMsbIJGjJtluPzTstch9jbFjiLsYWfGxUVZ96zHBd5UqYOF/ksxkV+IHPZwncylhhb+LlRCToSnIo5VtbhIp/FuMgPZErpsegBjw6f96zD5z3L8XmnZeqYY4nxeaczrRyfd1rmOsTeaYHF2MLPjYqKM+9Zjos8LVPFmfcsxkV+IHPZwncylhhb+LlR0bETKcdFnpapYydSjIv8QKaUHose8Ojwec86fN6zHJ93WqaOOZYYn3c608rxeadlhtUCty2wGFv4uVFRceY9y3GRp2WqOPOexbjI0zKXLXwvY4mxhZ8bFR07kXJc5GmZQUeC0zHHEmMLTw94dPi8Zx0+71mOzzspU47POy1Tx5l3OT7vtMx1iL3TAouxhZ8bFR1n3uW4yNMydZx5F+MiP5C5bOE7GUuMLfzcqOjYiZTjIk/L1LETKcZFfiBTSo9FD3h0+LxnHT7vWY7POy1TxxxLjM87nWnl+LzTMtch9k4LLMYWfm5Ugo4Ep2OOpcNFPotxkR/IXLbwvYy1xl6dqOhwkc9yXORpmTp2IsW4yA9kBhUDHh0+71mHz3uW4/NOy9QxxxLj805m2iLH552WuQ6xty1wEWMLPzcqKs68FxN0yFRx5r2IcZEfyFy28L2MtcZevaio2IksclzkaZkqdiKLGBf5gUwpPRY54Ck6fN6LDp/3IsfnnZapYo5VxPi8DzKtjjmWGJ/3qS2wGFv4uVFRcea9yHGRp2UGHQlOxxxr2cJ3M9Yae/WiomInsshxkSdl6nCRL2Jc5AcypfRY9IBHh8970eHzXuT4vNMydcyxxPi8DzKtjjmWGJ/3qS2wGFv4uVFRcea9yHGRp2WqOPNexLjID2QuW/hexlpjr15UdOxEynGRp2Xq2IkU4yI/kCmlx6IHPMA+727Lmbe/a4trmOO2TSPm4bLMcZubEXPcBmTEHLdJGDHHrfsj5rilfMAc2H98xBy44EZr9j4+xoY58JxiwBx49DBgjltDR8yBBwQD5sA38QPmwDfaA+bA984D5sC3wzRzZMPoAfPL1lBkn+YB88vWUGQ35QHzy9ZQZM/jAfPL1lBkZ+IBcx1HI+WYDdMydWzbizEbHsjUsW0vxw6Ylrm27Tsb1GLcg+dGRce2vRiz4YFMHdv2cuyAaZnrieBOxhLjHjw3KjoebhFjNjyQqeMBYjlmw7RMKT0WffxKh9lwkWM2TMmscsyGaZkq5lhVjHswmWmrHDtgWmZYLXDTAlcx7sFzo6LiAeIqxmx4IFPFA8RVjh0wKVOMHfDUjCXGPXhuVFTsRFYxZsMDmUFHglMxx6pizIbJAU/VYTZc5ZgN0zJ1zLHEmA0PZKqwqqty7IBpmett7p0WWIx78NyoqDDCq2LMhgcyVRjhVTl2wLTMZYTXyVhi3IPnRkXHTqQYs+GBTB07kXLMhmmZUnosesCjw2y4yjEbpmXqmGOJMRumZYpxD6YzrRw7YFrmOsTeaYHFuAfPjUrQkeB0zLHEuAcPEpyOOZYYO+C5GWuNvTpRkWM2TCY4MWbDA5k6diKBnYmnygwqBjzAnsdTv5s65ljAbspTZeqYYwH7NM/MtMCmzlNlrkPsnRYY2V36FaOi48w7ss31TJk6zrwjG2jPlLne5t7LWGvs1YuKjp1IZEvxmTJ17EQim5XPlCmlx6IHPMg26DO/mzrmWMgG6zNl6phjIVu3z8y0OuZYYnzep7bAYmzh50ZFx5l3OS7ytMygI8HpmGMtW/huxlpjr15UdOxEynGRJ2XqcJGvYlzkBzKl9Fj0gEeHz3vV4fNe5fi80zJ1zLHE+LwPMq2OOZYYn/eZLbA1YnzhJ4dFxan3TaeKUdamU8W5901nUKJzmcN309aafnXDomJHctOpYqC16VSxJ2mNGEP5kU4p3RY57Nl0Kum2dLi+bzqDEp0q5lqbThWH4DedKiZbm851rr3XDouxip8bFh3W8ptOJbMtHebym04ls63lF99PW2sU1g2Lik3KTaeS2ZYOi/lNp5LZlhjX+MHMR4cP/KZTyWxLjhP8QGdQolPFufhNp5LZlhg3+LntsBj3+MlhUXE23ho5dvMDnSpOx286lcy2loV8N22J8ZCfHBYl+5RyTOcHOpXsU4qxnR/plNJtDWY+OqzhN51KZltyzOEHOpXMtsTYww/yrRx/+IHOdey91w6LMZSfHBYlp+TlONDTOnVY0G86lcy2lqt8N22JsZWfHJagJMspmW3pMKLfdCqZbYnxlh/MfHS4xVujwy5+06lktiXHMH6gU8kpeTmW8QOd69h7rx0W4zE/OSxKTsnLMaUf6FRySl6MLf1I5zKa76UtMU7zk8OiZJ9SjjX9QKeSfUox5vQjnVK6rcHMR4eB/KZTyWxLjoX8QKeS2ZYYE/lBvpXjIj/QGVY73GmHxdjOTw6LklPycnzqBzqVnJIX41RP67TLer6XtqwY6/nJYdGxT2nlONUPdAYlWU7HbMuKsZ6nZz5WiZe8VeIlb+V4ydM65XjJD3TqOCVv5XjJD3SuY++9dliM9fzksOg4JW/lONUPdOo4JW/FONWPdC7r+V7aEmM9PzksOvYprRyn+oFOHfuUVoxT/UinlG5rMPNR4iVvlXjJWzle8gOdSmZbYrzkB/lWjpf8QOc69t5rh8VYz08OS1CS5ZTMtpQ41VsxTvUjnct6vpu21iisFxYlTvVWjlP9QKeSfUoxTvUjnUHHzEeJl7xV4iVv5XjJD3QqmW2J8ZIf5Fs5XvIDnevYe68dFmM9PzksSk7Jy3GqH+hUckpejFP9SOeynu+mrTUK64ZFyT6lHKf6gU4l+5RinOpHOqV0W4OZjxIveavES97K8ZIf6FQy2xLjJT/Kt0pmW2K85Oe2w2Ks5yeHRckpeTlO9QOdQUmWUzLbWtbz/bS1RmHdsCjZp5TjVE/rVOJUb8U41Y90Sum2BjMfYC95t2XO29/d/nu01AMs9WCy+3ptsD601HF7oiF13DZnSB23FQk25Bt1Z90oAZS9GG0FNtjB5U9ek7fLn54WawOD24y8cmBwu5fXDQywVfyZgWn7QGBv+ZcNjLf7DY/1rraBwW2oXjkwuB3YKwcmrMD0AwPcPb5uYIB709cNjNbOdxgYrZ3vMDBaO99BYBywbf8rB2Z1vgeBWZ3vQWBW53sQmCAkMMWYuo+qTQ6Dy10Iu0IXim0DI6XzLa7EPTDexlaplFZ2rFRKb1pCuCsNKbdKgZtN5/yuNPqR0uzuO1A5uVYpcPc4VynwewW+U2mJ99VbyuCAQ6rmVsJStfel/qS1ubhsef3rxcU9i+F28d8xBO4cLxND4CbzMjEE7kcvE8OwYvhwDIG73MvEELh/vkwMgTvzy8RQTM//ijEUczfxejEEfsXGdWK47lMej+G6T3k8hus+5fEYhhXDh2O47lMej+G6T3k8hus+5fEYrvuUx2O47lMejiHwu2yuE8N1n/J4DNd9yuMxXPcpj8cwrBg+HMN1n/J4DNd9yuMxXPcpj8dw3ac8HsN1n/JwDIHf03SdGK77lMdjuO5THo/huk95PIZhxfDhGK77lMdjuO5THo/huk95PIbrPuXxGK77lIdjCPz+tOvEcN2nPB7DdZ/yeAzXfcrjMQwrhg/HcN2nPB7DdZ/yeAzXfcrjMezfp2TvdkLVPY/h36h+Z173x+VtTbFB9d//5ky8MXTmufYbyrJQjoXyLFRgoSILlViozEIVFqpyUJm1NjJrbWTW2sistZFZayOz1kZmrY3MWhuZtTYya20U1toorLVRWGujsNZGYa2NwlobhbU2CmttFNbaKKy1UVlro3732th++fHXDx8/fvj3Pz9+/undlw+fP/32BDVP/3PwNo+Udu/97cfGO6T/ZRiA+t+FEchyQI4D8hxQ4IAiB5Q4oMwBcVZE4ayIylkRlbMiKmdFVM6KqJwVUTkrom8Zm3LM91a/8SHrm2Nm425dfDYhfwM6MI4cgSwH5Dgg3wdZQ4FKHxTLDmpe3HFgDjUAWcMBWQ6or8nbPXreN4HoP6I+APWfyR6BLAfUXxE+pB2USgPyHFDggCIHlIag7L8F+YOQ1x0UTG1AlgNyHJDngAIH1I9e8PsyCuHbN6gcHNgagfr0SrpNGHLJLSj3PynX/ZOKaUCFA6oMUH83I8e6ByKZZu31x6a5mLAHoqlPB3PCESgzQt6fBI1AlQHqz4FGIMsBOQ7Ic0CcVZ4iB5Q4IM6KSJwVkTgroj+RyWk3X8zJNwWgP5AZgQIHFDmgxAFlDqhwQJUB6t99/g+ozUb9u88RyHFAngM6WBF5z7CpNOWzf6eWs91XeXbfWt0ezCpGIMsBOQ6oH72tR76DUgMKHFDkgBIHlDmgwgHV7wf5gzu1bZnuoBQbkB+2BG7ktB3K/vrL7edmfXtzUM5cPm47vGE0ON4kDihzQIUDqgzQwc0qAdp+sU+X9ov7yDG+X92HqMJCVQ6qv70zRFkWyrFQnoUKLFT/AEWK+wtPt5+bm9eDF4yPUJmFKixUPUAVd0c1L9s9eHXyCNWPfEr7PZhN2X7bwRy8eHUr9ndd2+zvW1RioTILVViog8jnuu/Ip9JMAQ7e4jhCWRbKsVCehQosVGShDtZGuWeAVNy3JeLghVwjVGGhjtbGs+9XcaMzKttN0H75dpviBpfHdH9RZky2eYOoMYikLCIph0jKI5IKiKQiIqmESCq/BqlY7TNSzVafKXNI7afwno7OmOHd2X6jvv3sfEOqApKy4VVIkfex1kZEUgmRVEYkVRBJVUBS7qhLSPfmNecW5nmwwINFHizxYJkHKzxYZcG84cEsD8ZbJZ63Sg68y1K5v+UvlWZj3x7YdQ1hiQfLPFhhwQ5sY7ahxT131Ny8JO/AKWUIO4hkzXeStTaN2MGzy3lbdTdYts1hIHvwuO4IdvCE6hBmeTDHg3keLPBgkQdLPFg+gO1HILafa9MZHz05Yu+LKzsz2IiY+SxLrGCEkkEjZNEIOTRCHo1QQCMUwQgdbC1ltx93ffr5261Xe7Dfs23ShjuszXoHWzfZhXuydDE0sMSDHaRml5+TbAp4Pnqoz+79Wva+uYM/2L4ZwQ72b4Ywy4M5HszzYIEHO1glPj6DpWZNHuwzDWGZBys82NEqCc9hTZdRDQ9meTDHg3keLPBgkQc7WiX3Sea2WdgkhZp5sMKDVQ7s4CGJDVaew2wDszyY48E8DxZ4sMiDJR7sYJWEZ9U0+OYA58GYfAirLNjBS7eHsINVEuxzWHMu7uDVykOY58ECDxZ5sMSDZR7sYJW4em9nQhjYH9jg3X55aIvv0esiv/tT9gdJtp/TaB9pMJ89ev/id5NK8U6qPUd98IbCh6R3PsWd8in+lE8Jp3xKnPMpZW8MQjD+0SWZppAK5i59+/43n5LnS+98SjnlU+oZn+LNKZ8yJ1UEV+6fEh48dnz01p3vJhWeSY/NUW3v50vvfEo45VPiKZ+STvmUzBnJHL0SYgirLFgwPJjlwRwP5nmwwINFHizxYLxVEnirJPBWycE202Dn7cjhMRtzv2kztn2yNPBgkQdLPFjmwQoPVlmwoy2bEczyYI4H462SxFslibFK/tx++/93v3549+PH9082OU//+Punn26uOduvX/7zy+1fbr46v/z6+af3P//+6/snh527uc7TfxG/FQ4f6kbnSfq2S/N2G2T84+kk3NM/Wv/W2/L0q/3rWvd2u0PcH6l5usSV9Nab/BUfzdtkbmiXylv39x97Qj9N1l1Om4JNxX8B","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"use dep::sha256;\n\n/// Serializes a u64 value to a byte array\npub fn u64_to_bytes(value: u64) -> [u8; 8] {\n    let mut bytes = [0; 8];\n    \n    bytes[0] = (value & 0xFF) as u8;\n    bytes[1] = ((value >> 8) & 0xFF) as u8;\n    bytes[2] = ((value >> 16) & 0xFF) as u8;\n    bytes[3] = ((value >> 24) & 0xFF) as u8;\n    bytes[4] = ((value >> 32) & 0xFF) as u8;\n    bytes[5] = ((value >> 40) & 0xFF) as u8;\n    bytes[6] = ((value >> 48) & 0xFF) as u8;\n    bytes[7] = ((value >> 56) & 0xFF) as u8;\n    \n    bytes\n}\n\n/// Serializes an i64 value to a byte array\npub fn i64_to_bytes(value: i64) -> [u8; 8] {\n    // Convert to unsigned and handle negative values\n    let unsigned_value = if value < 0 {\n        ((-value) as u64) | (1 << 63) // Set the sign bit\n    } else {\n        value as u64\n    };\n    \n    u64_to_bytes(unsigned_value)\n}\n\n/// Generates the message hash that should be signed for image attestation\npub fn generate_image_attestation_hash(\n    image_hash: [u8; 32],\n    timestamp: u64,\n    device_id: u64,\n    latitude: i64,\n    longitude: i64,\n    gps_enabled: bool\n) -> [u8; 32] {\n    // Pack data for hashing\n    let mut data = [0; 128];\n    let mut index = 0;\n    \n    // Copy image hash to data\n    for i in 0..32 {\n        data[index] = image_hash[i];\n        index += 1;\n    }\n    \n    // Add timestamp bytes\n    let timestamp_bytes = u64_to_bytes(timestamp);\n    for i in 0..8 {\n        data[index] = timestamp_bytes[i];\n        index += 1;\n    }\n    \n    // Add device ID bytes\n    let device_id_bytes = u64_to_bytes(device_id);\n    for i in 0..8 {\n        data[index] = device_id_bytes[i];\n        index += 1;\n    }\n    \n    // Add GPS data if enabled\n    if gps_enabled {\n        // Add latitude and longitude\n        let lat_bytes = i64_to_bytes(latitude);\n        let long_bytes = i64_to_bytes(longitude);\n        \n        for i in 0..8 {\n            data[index] = lat_bytes[i];\n            index += 1;\n        }\n        \n        for i in 0..8 {\n            data[index] = long_bytes[i];\n            index += 1;\n        }\n    }\n    \n    // Add GPS flag\n    data[index] = if gps_enabled { 1 } else { 0 };\n    \n    // Hash the combined data using the external sha256 implementation\n    // Using digest function for fixed length data\n    sha256::digest(data)\n}\n\n#[test]\nfn test_generate_hash() {\n    // Test data\n    let test_image_hash = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32];\n    let test_timestamp = 1697380000;\n    let test_device_id = 12345;\n    let test_latitude = 340522;\n    let test_longitude = -1182437;\n    let test_gps_enabled = true;\n    \n    // Generate hash\n    let hash1 = generate_image_attestation_hash(\n        test_image_hash,\n        test_timestamp,\n        test_device_id,\n        test_latitude,\n        test_longitude,\n        test_gps_enabled\n    );\n    \n    // Generate again to verify determinism\n    let hash2 = generate_image_attestation_hash(\n        test_image_hash,\n        test_timestamp,\n        test_device_id,\n        test_latitude,\n        test_longitude,\n        test_gps_enabled\n    );\n    \n    // Hashes should match\n    assert(hash1 == hash2);\n    \n    // Test with different GPS flag\n    let hash3 = generate_image_attestation_hash(\n        test_image_hash,\n        test_timestamp,\n        test_device_id,\n        test_latitude,\n        test_longitude,\n        false // GPS disabled\n    );\n    \n    // Hashes should be different\n    assert(hash1 != hash3);\n} ","path":"/Users/sarkazein./Documents/Personal/Hackathon/Noirhack 25/trulens/src/lib.nr"},"62":{"source":"mod lib;\nuse dep::std::ecdsa_secp256k1;\n\n// Input struct for our image attestation\nstruct ImageAttestation {\n    // Hash of the original image\n    image_hash: [u8; 32],\n    // Timestamp of when the image was taken (unix timestamp in seconds)\n    timestamp: u64,\n    // Unique identifier for the device that took the image\n    device_id: u64,\n    // Optional GPS coordinates (if enabled)\n    latitude: i64,\n    longitude: i64,\n    // Flag indicating if GPS data is included\n    gps_enabled: bool,\n    // Signature (combined r and s components - 64 bytes)\n    signature: [u8; 64],\n    // Device's public key (for verification)\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32]\n}\n\n// Our main circuit function\nfn main(\n    image_hash: [u8; 32],\n    timestamp: u64,\n    device_id: u64,\n    latitude: i64,\n    longitude: i64,\n    gps_enabled: bool,\n    signature: [u8; 64],\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    // The hash that will be stored on-chain\n    attestation_hash: [u8; 32]\n) {\n    // Create our attestation struct\n    let attestation = ImageAttestation {\n        image_hash,\n        timestamp,\n        device_id,\n        latitude,\n        longitude,\n        gps_enabled,\n        signature,\n        public_key_x,\n        public_key_y\n    };\n    \n    // Generate the message hash for signature verification using the library function\n    let message_hash = lib::generate_image_attestation_hash(\n        attestation.image_hash,\n        attestation.timestamp,\n        attestation.device_id,\n        attestation.latitude,\n        attestation.longitude,\n        attestation.gps_enabled\n    );\n    \n    // Verify the device's signature using Noir's built-in ECDSA verification\n    let is_signature_valid = ecdsa_secp256k1::verify_signature(\n        attestation.public_key_x,\n        attestation.public_key_y,\n        attestation.signature,\n        message_hash\n    );\n    \n    // Ensure the signature is valid\n    assert(is_signature_valid);\n    \n    // Ensure the provided attestation hash matches our computed hash\n    assert(attestation_hash == message_hash);\n}\n\n#[test]\nfn test_attestation() {\n    // Test data\n    let test_image_hash = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32];\n    let test_timestamp = 1697380000;\n    let test_device_id = 12345;\n    let test_latitude = 340522;\n    let test_longitude = -1182437;\n    let test_gps_enabled = true;\n    \n    // Generate message hash\n    let message_hash = lib::generate_image_attestation_hash(\n        test_image_hash,\n        test_timestamp,\n        test_device_id,\n        test_latitude,\n        test_longitude,\n        test_gps_enabled\n    );\n    \n    // Verify hash generation is consistent\n    let hash2 = lib::generate_image_attestation_hash(\n        test_image_hash,\n        test_timestamp,\n        test_device_id,\n        test_latitude,\n        test_longitude,\n        test_gps_enabled\n    );\n    \n    assert(message_hash == hash2);\n}\n","path":"/Users/sarkazein./Documents/Personal/Hackathon/Noirhack 25/trulens/src/main.nr"},"67":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/sarkazein./nargo/github.com/noir-lang/sha256/v0.1.3/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","directive_integer_quotient","directive_to_radix"]}